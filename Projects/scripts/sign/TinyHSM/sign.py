#******************************************************************************
# * @file           : sign.py
# * @brief          : Prepends a header and appends a Tiny HSM signature for a binary
# ******************************************************************************
# * @attention
# *
# * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
# * All rights reserved.</center></h2>
# *
# * This software component is licensed by ST under BSD 3-Clause license,
# * the "License"; You may not use this file except in compliance with the
# * License. You may obtain a copy of the License at:
# *                        opensource.org/licenses/BSD-3-Clause
# ******************************************************************************

import logging
import sys
sys.path.append( '../../' )
import re
import hashlib
import argparse
from pathlib import Path
from utils.TinyHSM import *
from utils.stlink import *


DRIVE_NAMES = ['DIS_U585AI']
BOARDS =      ['B-U585I-IOT02A']


BOOTHEADER="SECUREBOOT10"
VERSIONFILE = "../../../FreeRTOS/{board_name}/Inc/application_version.h"
BINFILE = "../../../FreeRTOS/{board_name}/Debug/{board_name}_FreeRTOS.bin"
OUTPUTFILE = "../../../FreeRTOS/{board_name}/Debug/signed_binary.bin"
SIGGEN = "../../../SecureBoot/{board_name}/Src/SigGen.c"
DEFAULT_AWS_PROFILE='default'

parser = argparse.ArgumentParser(description='Script to append header and sign firmware image with U5 TinyHSM')
parser.add_argument("--board-name",     help="Name of board",                                                       required=True)
parser.add_argument("--version-file",   help="Path to application version file (default: "+VERSIONFILE+")",         required=False, default=VERSIONFILE)
parser.add_argument("--bin-file",       help="Path to firmware image (default: "+BINFILE+")",                       required=False, default=BINFILE)
parser.add_argument("--output-file",    help="Path to desired output signed binary file (default: "+OUTPUTFILE+")", required=False, default=OUTPUTFILE)
parser.add_argument("--sig-gen",        help="Path to sign gen file(default: "+SIGGEN+")",                          required=False, default=SIGGEN)
parser.add_argument("-d"              , help="degub output flag"                                                  , required=False, action="store_true"  )
args = parser.parse_args()

args.version_file = args.version_file.format(board_name=args.board_name)
args.bin_file = args.bin_file.format(board_name=args.board_name)
args.output_file = args.output_file.format(board_name=args.board_name)
args.sig_gen = args.sig_gen.format(board_name=args.board_name)

# Sign digest in the TinyHSM and return the signature as Bytes
def sign(digest, hsm:TinyHSM):
    sign  = hsm.stsafe_sign(hash_str=digest.hex())
    return sign

# Proceed to a sha256 hash of the string message
def hash(message):
    hash_digest = hashlib.sha256(message).digest()
    return hash_digest

# Open the bin file
def open_file(name):
    with open(name, "rb") as f:
        header = f.read()
    f.close()    
    return header

# Add a string to the bin file
def add_string(new_string, data):
    data += new_string.encode()
    hex_data = '00'
    data += bytes.fromhex(hex_data)
    return data
  
# Add 0xFF to have a specific allignment
def add_padding(size, data): 
    while((len(data) % size) != 0):
        hex_data = 'FF'
        new_data = bytes.fromhex(hex_data)
        data += new_data
    return data

# Read the revision number and return it as a string on the for of 0.9.1
def get_version():
    constants = dict()
    with open(args.version_file) as infile:
                for line in infile:
                    try:
                        matchFound = (re.findall(r"#define\s+(\w+)\s+(.*)", line.strip()))
                        if (len(matchFound) != 0):
                            constants.update(matchFound)
                    except Exception as e:
                            pass
    app_version = (constants["APP_VERSION_MAJOR"] + "." + constants["APP_VERSION_MINOR"] + "." + constants["APP_VERSION_BUILD"])
    return app_version          

# Generate Header files with the correct public key Qx and Qy
def generate_header_file(qx, qy):

    # Get the length of the string
    qx_s = hex(qx)
    qy_s = hex(qy)

    # Open a file for writing
    file = open(args.sig_gen, 'w')

    # Write data to the file
    file.write("/* File autogenerated by sign.py script */")
    file.write('\r\n')
    file.write('#include "main.h"\n\n')
    file.write('#define SigGen_Qx_len  32\n')
    file.write('#define SigGen_Qy_len  32\n')
    file.write('\n')

    file.write('const uint8_t SigGen_Qx[SigGen_Qx_len] = {')
    for i in range(2, len(qx_s), 2):
      file.write('0x')
      file.write(qx_s[i:i+2])
      if(i < len(qx_s) - 2):
        file.write(', ')
    file.write('};\n')

    file.write('const uint8_t SigGen_Qy[SigGen_Qy_len] = {')
    for i in range(2, len(qy_s), 2):
      file.write('0x')
      file.write(qy_s[i:i+2])
      if(i < len(qy_s) - 2):
        file.write(', ')               
    file.write('};\n')

    file.close()

# Initialize STLink Serial communication
def init_stlink(logger):
    try:
        _stlink = stlink()
    except Exception as e:
        logger.error(e)
        logger.info("Please close any application accessing your board's COM port" )
        exit()

    if(_stlink.drive_name in DRIVE_NAMES):
        position = DRIVE_NAMES.index(_stlink.drive_name)
        logger.debug(BOARDS[position] + " initialized")
    else:
        if(_stlink.drive_name):
            logger.error("Board not supported by the script")
            logger.info("Supported boards : " + str(BOARDS))
        else:
            logger.error("Board not found")
            logger.error("If your board is connected, then please make sure you are using a USB cable with data support")
        exit()

    logger.debug("ST-Link Path      : " + _stlink.path)
    logger.debug("ST-Link port      : " + _stlink.port)
    logger.debug("ST-Link drive_name: " + _stlink.drive_name)

    return _stlink

def main(argv):

    #Check the FreeRTOS binary is present
    file_path = Path(args.bin_file)
    if not Path.exists(file_path):
      print('[ERROR]:\t', file_path, " file not found!")
      exit()

    # Initialize Stlink and TinyHSM
    logger = logging.getLogger(__name__)
    _stlink = init_stlink(logger)
    hsm = TinyHSM(serial=_stlink.ser, debug=args.d)
    hsm.reset()
    hsm.signer_init()

    # Open the binary file
    bin = open_file(args.bin_file)
    bin = add_padding(512, bin)
    bin_size = len(bin)

    ## Build Header 
    # Add Secure boot revision number to header
    boot_header = BOOTHEADER + '\0'
    header = boot_header.encode()
    header = add_padding(16, header)

    # Add App size to header
    app_size = str(bin_size + 512) + '\0'
    header = add_string(app_size, header)
    header = add_padding(16, header)

    # Add board name to header
    boardName = args.board_name
    header = add_string(boardName, header)
    header = add_padding(16, header)
    
    # Add the firmware revision number to header
    app_version = get_version()
    header = add_string(app_version, header)
    header = add_padding(512, header)

    # Add the header to the binary
    header += bin
   
    #Hash the binary
    digest = hash(header)

    # Init the signing public key
    vk = hsm.stsafe_get_signer_public_key()

    # Sign the binary 
    signature = sign(digest, hsm)
  
    # Get public key qx and qy
    qx = vk.pubkey.point.x()
    qy = vk.pubkey.point.y()
    qx_hex = hex(qx)
    qy_hex = hex(qy)

    # Print the public key, digest, signature on the console (For debug purpose)
    print("qx         :", qx_hex)
    print("qy         :", qy_hex)
    print("digest     :", digest.hex())  
    print("Signature  :", signature.hex())

    # Generate Header files SinGen.c for the FreeRTOS project
    generate_header_file(qx, qy)

    # Verify the signature (for debug purpose)
    print(vk.verify_digest(signature, digest))
    
    # Add the signature to the binary file
    header += signature 

    # Write the new binary file
    with open(args.output_file, 'wb') as f:
        f.write(header)
        f.close()

################################
if __name__ == "__main__":
    main(sys.argv[1:])

